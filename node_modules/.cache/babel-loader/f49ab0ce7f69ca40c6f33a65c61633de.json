{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridDensityRowHeightSelector, gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridFilterStateSelector } from '../filter/gridFilterSelector';\nimport { gridPaginationSelector } from '../pagination/gridPaginationSelector';\nimport { gridSortingStateSelector } from '../sorting/gridSortingSelector';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport const rowsMetaStateInitializer = state => _extends({}, state, {\n  rowsMeta: {\n    currentPageTotalHeight: 0,\n    positions: []\n  }\n});\n/**\n * @requires useGridPageSize (method)\n * @requires useGridPage (method)\n */\n\nexport const useGridRowsMeta = (apiRef, props) => {\n  const {\n    getRowHeight: getRowHeightProp,\n    getRowSpacing,\n    getEstimatedRowHeight\n  } = props;\n  const rowsHeightLookup = React.useRef({}); // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n\n  const lastMeasuredRowIndex = React.useRef(-1);\n  const hasRowWithAutoHeight = React.useRef(false);\n  const rowHeightFromDensity = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  const filterState = useGridSelector(apiRef, gridFilterStateSelector);\n  const paginationState = useGridSelector(apiRef, gridPaginationSelector);\n  const sortingState = useGridSelector(apiRef, gridSortingStateSelector);\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const hydrateRowsMeta = React.useCallback(() => {\n    hasRowWithAutoHeight.current = false;\n    apiRef.current.setState(state => {\n      const densityFactor = gridDensityFactorSelector(state, apiRef.current.instanceId);\n      const positions = [];\n      const currentPageTotalHeight = currentPage.rows.reduce((acc, row) => {\n        positions.push(acc);\n\n        if (!rowsHeightLookup.current[row.id]) {\n          rowsHeightLookup.current[row.id] = {\n            sizes: {\n              base: rowHeightFromDensity\n            },\n            isResized: false,\n            autoHeight: false,\n            needsFirstMeasurement: true // Assume all rows will need to be measured by default\n\n          };\n        }\n\n        const {\n          isResized,\n          needsFirstMeasurement,\n          sizes\n        } = rowsHeightLookup.current[row.id];\n        let baseRowHeight = rowHeightFromDensity;\n        const existingBaseRowHeight = sizes.base;\n\n        if (isResized) {\n          // Do not recalculate resized row height and use the value from the lookup\n          baseRowHeight = existingBaseRowHeight;\n        } else if (getRowHeightProp) {\n          const rowHeightFromUser = getRowHeightProp(_extends({}, row, {\n            densityFactor\n          }));\n\n          if (rowHeightFromUser === 'auto') {\n            if (needsFirstMeasurement) {\n              const estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(_extends({}, row, {\n                densityFactor\n              })) : rowHeightFromDensity; // If the row was not measured yet use the estimated row height\n\n              baseRowHeight = estimatedRowHeight != null ? estimatedRowHeight : rowHeightFromDensity;\n            } else {\n              baseRowHeight = existingBaseRowHeight;\n            }\n\n            hasRowWithAutoHeight.current = true;\n            rowsHeightLookup.current[row.id].autoHeight = true;\n          } else {\n            // Default back to base rowHeight if getRowHeight returns null or undefined.\n            baseRowHeight = rowHeightFromUser != null ? rowHeightFromUser : rowHeightFromDensity;\n            rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n            rowsHeightLookup.current[row.id].autoHeight = false;\n          }\n        } else {\n          rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n        } // We use an object to make simple to check if a height is already added or not\n\n\n        const initialHeights = {\n          base: baseRowHeight\n        };\n\n        if (getRowSpacing) {\n          var _spacing$top, _spacing$bottom;\n\n          const indexRelativeToCurrentPage = apiRef.current.getRowIndexRelativeToVisibleRows(row.id);\n          const spacing = getRowSpacing(_extends({}, row, {\n            isFirstVisible: indexRelativeToCurrentPage === 0,\n            isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,\n            indexRelativeToCurrentPage\n          }));\n          initialHeights.spacingTop = (_spacing$top = spacing.top) != null ? _spacing$top : 0;\n          initialHeights.spacingBottom = (_spacing$bottom = spacing.bottom) != null ? _spacing$bottom : 0;\n        }\n\n        const processedSizes = apiRef.current.unstable_applyPipeProcessors('rowHeight', initialHeights, row);\n        rowsHeightLookup.current[row.id].sizes = processedSizes;\n        const finalRowHeight = Object.values(processedSizes).reduce((acc2, value) => acc2 + value, 0);\n        return acc + finalRowHeight;\n      }, 0);\n      return _extends({}, state, {\n        rowsMeta: {\n          currentPageTotalHeight,\n          positions\n        }\n      });\n    });\n\n    if (!hasRowWithAutoHeight.current) {\n      // No row has height=auto, so all rows are already measured\n      lastMeasuredRowIndex.current = Infinity;\n    }\n\n    apiRef.current.forceUpdate();\n  }, [apiRef, currentPage.rows, rowHeightFromDensity, getRowHeightProp, getRowSpacing, getEstimatedRowHeight]);\n  const getRowHeight = React.useCallback(rowId => {\n    const height = rowsHeightLookup.current[rowId];\n    return height ? height.sizes.base : rowHeightFromDensity;\n  }, [rowHeightFromDensity]);\n\n  const getRowInternalSizes = rowId => {\n    var _rowsHeightLookup$cur;\n\n    return (_rowsHeightLookup$cur = rowsHeightLookup.current[rowId]) == null ? void 0 : _rowsHeightLookup$cur.sizes;\n  };\n\n  const setRowHeight = React.useCallback((id, height) => {\n    rowsHeightLookup.current[id].sizes.base = height;\n    rowsHeightLookup.current[id].isResized = true;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]);\n  const storeMeasuredRowHeight = React.useCallback((id, height) => {\n    if (!rowsHeightLookup.current[id] || !rowsHeightLookup.current[id].autoHeight) {\n      return;\n    } // Only trigger hydration if the value is different, otherwise we trigger a loop\n\n\n    const needsHydration = rowsHeightLookup.current[id].sizes.base !== height;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    rowsHeightLookup.current[id].sizes.base = height;\n\n    if (needsHydration) {\n      hydrateRowsMeta();\n    }\n  }, [hydrateRowsMeta]);\n  const rowHasAutoHeight = React.useCallback(id => {\n    var _rowsHeightLookup$cur2;\n\n    return ((_rowsHeightLookup$cur2 = rowsHeightLookup.current[id]) == null ? void 0 : _rowsHeightLookup$cur2.autoHeight) || false;\n  }, []);\n  const getLastMeasuredRowIndex = React.useCallback(() => {\n    return lastMeasuredRowIndex.current;\n  }, []);\n  const setLastMeasuredRowIndex = React.useCallback(index => {\n    if (hasRowWithAutoHeight.current) {\n      lastMeasuredRowIndex.current = index;\n    }\n  }, []); // The effect is used to build the rows meta data - currentPageTotalHeight and positions.\n  // Because of variable row height this is needed for the virtualization\n\n  React.useEffect(() => {\n    hydrateRowsMeta();\n  }, [rowHeightFromDensity, filterState, paginationState, sortingState, hydrateRowsMeta]);\n  useGridRegisterPipeApplier(apiRef, 'rowHeight', hydrateRowsMeta);\n  const rowsMetaApi = {\n    unstable_getLastMeasuredRowIndex: getLastMeasuredRowIndex,\n    unstable_setLastMeasuredRowIndex: setLastMeasuredRowIndex,\n    unstable_rowHasAutoHeight: rowHasAutoHeight,\n    unstable_getRowHeight: getRowHeight,\n    unstable_getRowInternalSizes: getRowInternalSizes,\n    unstable_setRowHeight: setRowHeight,\n    unstable_storeRowHeightMeasurement: storeMeasuredRowHeight\n  };\n  useGridApiMethod(apiRef, rowsMetaApi, 'GridRowsMetaApi');\n};","map":{"version":3,"sources":["/home/shikhar/inshort/COVID-19-Details/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRowsMeta.js"],"names":["_extends","React","useGridVisibleRows","useGridApiMethod","useGridSelector","gridDensityRowHeightSelector","gridDensityFactorSelector","gridFilterStateSelector","gridPaginationSelector","gridSortingStateSelector","useGridRegisterPipeApplier","rowsMetaStateInitializer","state","rowsMeta","currentPageTotalHeight","positions","useGridRowsMeta","apiRef","props","getRowHeight","getRowHeightProp","getRowSpacing","getEstimatedRowHeight","rowsHeightLookup","useRef","lastMeasuredRowIndex","hasRowWithAutoHeight","rowHeightFromDensity","filterState","paginationState","sortingState","currentPage","hydrateRowsMeta","useCallback","current","setState","densityFactor","instanceId","rows","reduce","acc","row","push","id","sizes","base","isResized","autoHeight","needsFirstMeasurement","baseRowHeight","existingBaseRowHeight","rowHeightFromUser","estimatedRowHeight","initialHeights","_spacing$top","_spacing$bottom","indexRelativeToCurrentPage","getRowIndexRelativeToVisibleRows","spacing","isFirstVisible","isLastVisible","length","spacingTop","top","spacingBottom","bottom","processedSizes","unstable_applyPipeProcessors","finalRowHeight","Object","values","acc2","value","Infinity","forceUpdate","rowId","height","getRowInternalSizes","_rowsHeightLookup$cur","setRowHeight","storeMeasuredRowHeight","needsHydration","rowHasAutoHeight","_rowsHeightLookup$cur2","getLastMeasuredRowIndex","setLastMeasuredRowIndex","index","useEffect","rowsMetaApi","unstable_getLastMeasuredRowIndex","unstable_setLastMeasuredRowIndex","unstable_rowHasAutoHeight","unstable_getRowHeight","unstable_getRowInternalSizes","unstable_setRowHeight","unstable_storeRowHeightMeasurement"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridDensityRowHeightSelector, gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridFilterStateSelector } from '../filter/gridFilterSelector';\nimport { gridPaginationSelector } from '../pagination/gridPaginationSelector';\nimport { gridSortingStateSelector } from '../sorting/gridSortingSelector';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport const rowsMetaStateInitializer = state => _extends({}, state, {\n  rowsMeta: {\n    currentPageTotalHeight: 0,\n    positions: []\n  }\n});\n/**\n * @requires useGridPageSize (method)\n * @requires useGridPage (method)\n */\n\nexport const useGridRowsMeta = (apiRef, props) => {\n  const {\n    getRowHeight: getRowHeightProp,\n    getRowSpacing,\n    getEstimatedRowHeight\n  } = props;\n  const rowsHeightLookup = React.useRef({}); // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n\n  const lastMeasuredRowIndex = React.useRef(-1);\n  const hasRowWithAutoHeight = React.useRef(false);\n  const rowHeightFromDensity = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  const filterState = useGridSelector(apiRef, gridFilterStateSelector);\n  const paginationState = useGridSelector(apiRef, gridPaginationSelector);\n  const sortingState = useGridSelector(apiRef, gridSortingStateSelector);\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const hydrateRowsMeta = React.useCallback(() => {\n    hasRowWithAutoHeight.current = false;\n    apiRef.current.setState(state => {\n      const densityFactor = gridDensityFactorSelector(state, apiRef.current.instanceId);\n      const positions = [];\n      const currentPageTotalHeight = currentPage.rows.reduce((acc, row) => {\n        positions.push(acc);\n\n        if (!rowsHeightLookup.current[row.id]) {\n          rowsHeightLookup.current[row.id] = {\n            sizes: {\n              base: rowHeightFromDensity\n            },\n            isResized: false,\n            autoHeight: false,\n            needsFirstMeasurement: true // Assume all rows will need to be measured by default\n\n          };\n        }\n\n        const {\n          isResized,\n          needsFirstMeasurement,\n          sizes\n        } = rowsHeightLookup.current[row.id];\n        let baseRowHeight = rowHeightFromDensity;\n        const existingBaseRowHeight = sizes.base;\n\n        if (isResized) {\n          // Do not recalculate resized row height and use the value from the lookup\n          baseRowHeight = existingBaseRowHeight;\n        } else if (getRowHeightProp) {\n          const rowHeightFromUser = getRowHeightProp(_extends({}, row, {\n            densityFactor\n          }));\n\n          if (rowHeightFromUser === 'auto') {\n            if (needsFirstMeasurement) {\n              const estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(_extends({}, row, {\n                densityFactor\n              })) : rowHeightFromDensity; // If the row was not measured yet use the estimated row height\n\n              baseRowHeight = estimatedRowHeight != null ? estimatedRowHeight : rowHeightFromDensity;\n            } else {\n              baseRowHeight = existingBaseRowHeight;\n            }\n\n            hasRowWithAutoHeight.current = true;\n            rowsHeightLookup.current[row.id].autoHeight = true;\n          } else {\n            // Default back to base rowHeight if getRowHeight returns null or undefined.\n            baseRowHeight = rowHeightFromUser != null ? rowHeightFromUser : rowHeightFromDensity;\n            rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n            rowsHeightLookup.current[row.id].autoHeight = false;\n          }\n        } else {\n          rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n        } // We use an object to make simple to check if a height is already added or not\n\n\n        const initialHeights = {\n          base: baseRowHeight\n        };\n\n        if (getRowSpacing) {\n          var _spacing$top, _spacing$bottom;\n\n          const indexRelativeToCurrentPage = apiRef.current.getRowIndexRelativeToVisibleRows(row.id);\n          const spacing = getRowSpacing(_extends({}, row, {\n            isFirstVisible: indexRelativeToCurrentPage === 0,\n            isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,\n            indexRelativeToCurrentPage\n          }));\n          initialHeights.spacingTop = (_spacing$top = spacing.top) != null ? _spacing$top : 0;\n          initialHeights.spacingBottom = (_spacing$bottom = spacing.bottom) != null ? _spacing$bottom : 0;\n        }\n\n        const processedSizes = apiRef.current.unstable_applyPipeProcessors('rowHeight', initialHeights, row);\n        rowsHeightLookup.current[row.id].sizes = processedSizes;\n        const finalRowHeight = Object.values(processedSizes).reduce((acc2, value) => acc2 + value, 0);\n        return acc + finalRowHeight;\n      }, 0);\n      return _extends({}, state, {\n        rowsMeta: {\n          currentPageTotalHeight,\n          positions\n        }\n      });\n    });\n\n    if (!hasRowWithAutoHeight.current) {\n      // No row has height=auto, so all rows are already measured\n      lastMeasuredRowIndex.current = Infinity;\n    }\n\n    apiRef.current.forceUpdate();\n  }, [apiRef, currentPage.rows, rowHeightFromDensity, getRowHeightProp, getRowSpacing, getEstimatedRowHeight]);\n  const getRowHeight = React.useCallback(rowId => {\n    const height = rowsHeightLookup.current[rowId];\n    return height ? height.sizes.base : rowHeightFromDensity;\n  }, [rowHeightFromDensity]);\n\n  const getRowInternalSizes = rowId => {\n    var _rowsHeightLookup$cur;\n\n    return (_rowsHeightLookup$cur = rowsHeightLookup.current[rowId]) == null ? void 0 : _rowsHeightLookup$cur.sizes;\n  };\n\n  const setRowHeight = React.useCallback((id, height) => {\n    rowsHeightLookup.current[id].sizes.base = height;\n    rowsHeightLookup.current[id].isResized = true;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]);\n  const storeMeasuredRowHeight = React.useCallback((id, height) => {\n    if (!rowsHeightLookup.current[id] || !rowsHeightLookup.current[id].autoHeight) {\n      return;\n    } // Only trigger hydration if the value is different, otherwise we trigger a loop\n\n\n    const needsHydration = rowsHeightLookup.current[id].sizes.base !== height;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    rowsHeightLookup.current[id].sizes.base = height;\n\n    if (needsHydration) {\n      hydrateRowsMeta();\n    }\n  }, [hydrateRowsMeta]);\n  const rowHasAutoHeight = React.useCallback(id => {\n    var _rowsHeightLookup$cur2;\n\n    return ((_rowsHeightLookup$cur2 = rowsHeightLookup.current[id]) == null ? void 0 : _rowsHeightLookup$cur2.autoHeight) || false;\n  }, []);\n  const getLastMeasuredRowIndex = React.useCallback(() => {\n    return lastMeasuredRowIndex.current;\n  }, []);\n  const setLastMeasuredRowIndex = React.useCallback(index => {\n    if (hasRowWithAutoHeight.current) {\n      lastMeasuredRowIndex.current = index;\n    }\n  }, []); // The effect is used to build the rows meta data - currentPageTotalHeight and positions.\n  // Because of variable row height this is needed for the virtualization\n\n  React.useEffect(() => {\n    hydrateRowsMeta();\n  }, [rowHeightFromDensity, filterState, paginationState, sortingState, hydrateRowsMeta]);\n  useGridRegisterPipeApplier(apiRef, 'rowHeight', hydrateRowsMeta);\n  const rowsMetaApi = {\n    unstable_getLastMeasuredRowIndex: getLastMeasuredRowIndex,\n    unstable_setLastMeasuredRowIndex: setLastMeasuredRowIndex,\n    unstable_rowHasAutoHeight: rowHasAutoHeight,\n    unstable_getRowHeight: getRowHeight,\n    unstable_getRowInternalSizes: getRowInternalSizes,\n    unstable_setRowHeight: setRowHeight,\n    unstable_storeRowHeightMeasurement: storeMeasuredRowHeight\n  };\n  useGridApiMethod(apiRef, rowsMetaApi, 'GridRowsMetaApi');\n};"]},"metadata":{},"sourceType":"module"}